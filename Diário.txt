================================================================================
04/11/2017 22:05
	Tirei a tarde/noite para começar o trabalho
	Ainda não recebemos o projeto do professor
	Organizei o projeto em múltiplos arquivos separados em múltiplas pastas
	e montei um makefile
	Começei de verdade o estruturas.h e Implementei as funções:
	var_elemento*  aloca_elemento(void);

	var_lista*     aloca_lista   (void);

	void           free_lista    (var_lista* lista);

	bool           lista_vazia   (var_lista* lista);

	void           insere_final  (void* info, var_lista* lista, int codigo);

	void           deleta_ultimo (var_lista* lista);

	void           print_lista   (var_lista* lista, int codigo);
================================================================================
06/11/2017 10:00
	Começei o dia depurando as funções escritas no sábado com gdb e valgrind
	Erro encontrado:
		'aloca_elemento', conforme especificado, inicia os ponteiros com valor
		"NULL", portanto tentar escrever no endereço "NULL" gera uma falha de
		segmentação.
		Correção:
			inserir o comando "elemento->dados = (void*) malloc(sizeof(int));"
	Erro encontrado:
		'insere_final' foi chamado com o código de inserção de var_elemento,
		entretanto,	recebe um (void*).
		Correção:
			inserir "elemento" como parâmetro ao invés de "elemento->dados"
	Comportamento não desejado:
		Função 'print_lista' imprime índices de forma decrescente.
		Correção:
			"indice" é inicializado com valor 0 e "indice++" é substituído por
			"++indice"
	Comportamento não desejado:
		A função 'insere_final' independente do comando, vincula a informação
		com o ponteiro, ou seja, se na origem da chamada da função eu liberar
		a memória do parâmetro enviado a função ele libera a informação na
		lista.
		Correção temporária:
			Os parâmetros informados devem ser "presenteados" a função,
			não havendo nenhuma modificação àquela área de memória posterior
			a chamada da função.
	Erro encontrado:
		'free_lista' não considera áreas de memória alocadas dinamicamente
		dependentes, ou seja, que estão ligadas ao "var_elemento"
		Correção:
			inserir a linha "free(cursor->dados);" antes de "free(cursor);"
	Erro encontrado:
		Erro de natureza semelhante ao anterior encontrado em 'deleta_ultimo'
		Correção:
			inserir a linha "if(lista->ultimo->dados != NULL)
			{free(lista->ultimo->dados);}" antes de "free(lista->ultimo);"
	Ao final da tarde começei a implementar uma função para terceirizar
	o processo de alocação de memória para os principais tipos usados
	durante a solução do problema.
	Entretanto achei estéticamente feio e pouco prático, então retirei.
================================================================================
08/11/2017 17:00
	Recebi o pedido para o trabalho ontem
	Modificarei a definição de lista simplemente encadeada implementada
	para uma lista duplamente encadeada:

	typedef struct elemento{
		void* dados;
		struct elemento* anterior;
	    struct elemento* proximo;
	} var_elemento;

	Incluindo modificações nas seguintes funções:
	var_elemento*	aloca_elemento (void)

	void			insere_final (void* info, var_lista* lista, int codigo);

	Ampliando a função 'insere_final' surgiu:
	void			insere (int finalouinicio, void* info, var_lista* lista,
 int codigo);

	Começei a implementar a biblioteca 'character.h'
================================================================================
12/11/2017 15:30
	Começei a tarde criando um repositório
	https://github.com/thaleslim/GameGoT.git
	e começarei a testar as funções que imaginei enquanto
	estava impossibilitado de trabalhar no projeto,
	pretendo depurar as seguintes funções:
	t_node*     node_create(void);

	t_node*     tree_create(void);

	t_node*     aloca_arvore(int total_de_nos);

	void        tree_free(t_node* tree);

	void        tree_print_preorder(t_node* root);

	Resolvi compartimentar cada estrutura de dados em seu próprio
	cabeçalho
	Observação: existe a possibilidade,apesar de minima, de existirem erros de construção
	  			da estrutura de árvore.
================================================================================
16/11/2017 14:30
	Objetivos: implementar a estrutura de fila
	usando listas duplamente encadeadas.
	Testar modificações para
	generalizar o comportamento de inserir adicionando
	uma variável, que seria a quantidade de bytes da
	informação que o usuário quer inserir.
	E começar a implementar funções mais específicas de
	modelagem do jogo.
================================================================================
17/11/2017 18:00
	Objetivos:  Depurar estrutura de fila;
				Atualizar git repo;
				Voltar a desenvolver funções mais especificas do jogo em si.
	Erro: 'insere_lista' causa vazamento de memória
		Correção: usar chaves para abranger as 2 linhas de código
				do elseif caso contrário "memcpy(elemento, info, size_of_memory);"
				é executado todas as vezes.
	Comportamento não desejado: 'sair_fila' retorna um 'var_elemento'
		Correção: adicionar as seguintes ações"void *resultado=elemento->dados;
				free(elemento);"
	Estética: substituir LISTA VAZIA por VAZIA
			Como estamos usando print_lista para mais de uma estrutura, faz mais
			sentido dessa forma.
================================================================================
18/11/2017 12:15
	Objetivos:	Começar a modelar o gameloop
				Implementar funções de busca e impressão na árvore
	Começei criando o arquivo Sketch.c
	Esse arquivo contém o q eu imagino que seja necessário para
	a montagem do gameloop
================================================================================
22/11/2017 21:56
	Objetivos:	Testar character_create()
				Implementar LoadFromFile(), função mencionada em sketch.c
	Resultados do dia:

	Character* character_create(char* _name, char* _house, int _agility,
	int _strength, int _intelligence, int _health);

	void       character_free(Character* character);

	Character* fight(Character* fighter_one, Character* fighter_two,
	int atribute);

	void       print_character(Character* character, void* nerfs_n_buffs);

	Funções implementadas e testadas, entretanto print_character()
	será expandida para facilitar o trabalho de impressão levando
	em consideração dinâmicas do jogo, nesse caso imprimir
	"X) XXXXXX: XX" no atributo "exaurido" pelo usuário na batalha
	anterior.

	Testes realizados usando as seguintes estruturas Character:
	KungLao, Lao, 100, 30, 20, 100
	ChunLee, Lee, 15, 100, 100, 20
================================================================================
24/11/2017 20:53
	Obtive sucesso na leitura do arquivo personagens,
	havia encontrado alguma dificuldade por meu código
	não estar preparado para lidar com o char '\r'
	(Return Carriage); e não compreender completamente
	o retorno da função fscanf().
	Comportamento não desejado:
		Ainda não sei a abrangência desse caso, entretanto descobri
		que ao usarmos as funções de liberação (free_lista(),
		character_free(), etc) não excluímos o potencial para erros
		secundários, já que os ponteiros passados como argumentos,
		passam a apontar para uma área de memória previamente libe-
		rada, ou seja, existe a possibilidade de acessos indevidos.
		Correção:
			As funções de liberação passam a retornar o ponteiro NULL
			Exceto character_free(), já que foi especificado pelo
			trabalho o seu comportamento, nesse caso recomendo cautela.
================================================================================
25/11/2017 11:15
	Objetivos:	Depurar funções criadas ontem
				Revisar documentação
				Avançar no gameloop
	Começei o dia criando um padrão para me ajudar, todo arquivo de cabeçalho
	tem em sua primeira um link para o manual do Doxygen
	Depois organizei todos os Smoketest e Checklist em uma pasta com seu próprio
	makefile.
	Removi todos os SmokeTests e Checklists do Diário, com o objetivo de
	deixá-lo mais objetivo.
	IDEIAS: Usar arquivo texto para armazenar as informações dos rounds;
			Criar função que esvazia a lista e que receba um sinal que lhe
			informe sobre a liberação da memória de var_elemento;
================================================================================
26/11/2017 20:52
	Implementei função de esvaziar a lista,pop_lista,free_elemento
	E random_roullete, sendo que essa última ainda está causando vazamentos
	de memória que não consigo explicar
	IDEIA: é possivel que a memória vazada seja elemento::dados
================================================================================
26/11/2017 16:30
	Erro:	random_roullete() não considera que insere_lista() faz uma
			cópia do elemento
			Correção:	alocar uma variável temporária que irá receber
						o ponteiro de pop_lista() para posteriormente liberar.
	Objetivos: continuar avançando no gameloop
	Resumo do dia:
		Consegui implementar as funções random_roullete e LoadFighters;
		Para isso criei uma função que enfileira as folhas de uma árvore
		Corrigi um detalhe na função de esvaziar_lista(): o ponteiro ultimo
			ainda apontava para uma área de memória previamente liberada
		Corrigi também um detalhe na função sair_fila() : ela não respondia
			bem no caso em que var_lista::tamanho = 1
		Criei uma função chamada pop_lista, para trabalhar com random_roullete
	Falhas: Tenho deixado comentários e Smoketests um pouco de lado para tentar
			avançar mais rapidamente no desenvolvimento, necessito voltar com
			esse hábito e também preciso realizar as seguintes ações:
			-> atualizar funções de liberação para retornar ponteiro NULL
			-> expandir função print_character() para usar nerfs_n_buffs
			-> a função tree_free() também tem que liberar a memória de
				seus Character
				IDEIA: criar função node_free() para terceirizar o trabalho
						de liberação.
				IDEIA: usar função que enfileira_folhas, liberar as areas de
					   Character e depois ir liberando a arvore.
	Voltar a programar o Doxygen urgentemente.
	
