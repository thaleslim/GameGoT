================================================================================
04/11/2017 22:05
	Tirei a tarde/noite para começar o trabalho
	Ainda não recebemos o projeto do professor
	Organizei o projeto em múltiplos arquivos separados em múltiplas pastas
	e montei um makefile
	Começei de verdade o estruturas.h e Implementei as funções:
	var_elemento*  aloca_elemento(void);

	var_lista*     aloca_lista   (void);

	void           free_lista    (var_lista* lista);

	bool           lista_vazia   (var_lista* lista);

	void           insere_final  (void* info, var_lista* lista, int codigo);

	void           deleta_ultimo (var_lista* lista);

	void           print_lista   (var_lista* lista, int codigo);
	Proponho o seguinte Smoketest:
	#include "../headers/estruturas.h"
	#include <stdio.h>
	int main (void){
		var_lista* lista = aloca_lista();

		var_elemento* elemento = aloca_elemento();

		scanf("%d", (int*) elemento->dados);
		//Input: 3\n
		insere_final(elemento->dados,lista,INSERE_DADO_HEAP);

		scanf("%d", (int*) elemento->dados);
		//Input: 6\n
		insere_final(elemento->dados,lista,INSERE_VAR_ELEMENTO);

		deleta_ultimo(lista);
		//Esperado que o 6 seja deletado

		print_lista(lista,INT);

		free_lista(lista);
		return 0;
	}
	Ao executar o programa acima é esperado que ao final não existam
	vazamentos e seja impresso no terminal "1. 3".
	Checklist
		Primeira Tentativa 04/11/2017
		Resultado: Falha de Segmentação após o primeiro input
================================================================================
06/11/2017 10:00
	Começei o dia depurando as funções escritas no sábado com gdb e valgrind
	Erro encontrado:
		'aloca_elemento', conforme especificado, inicia os ponteiros com valor
		"NULL", portanto tentar escrever no endereço "NULL" gera uma falha de
		segmentação.
		Correção:
			inserir o comando "elemento->dados = (void*) malloc(sizeof(int));"
	Erro encontrado:
		'insere_final' foi chamado com o código de inserção de var_elemento,
		entretanto,	recebe um (void*).
		Correção:
			inserir "elemento" como parâmetro ao invés de "elemento->dados"
	Comportamento não desejado:
		Função 'print_lista' imprime índices de forma decrescente.
		Correção:
			"indice" é inicializado com valor 0 e "indice++" é substituído por
			"++indice"
	Comportamento não desejado:
		A função 'insere_final' independente do comando, vincula a informação
		com o ponteiro, ou seja, se na origem da chamada da função eu liberar
		a memória do parâmetro enviado a função ele libera a informação na
		lista.
		Correção temporária:
			Os parâmetros informados devem ser "presenteados" a função,
			não havendo nenhuma modificação àquela área de memória posterior
			a chamada da função.
	Erro encontrado:
		'free_lista' não considera áreas de memória alocadas dinamicamente
		dependentes, ou seja, que estão ligadas ao "var_elemento"
		Correção:
			inserir a linha "free(cursor->dados);" antes de "free(cursor);"
	Erro encontrado:
		Erro de natureza semelhante ao anterior encontrado em 'deleta_ultimo'
		Correção:
			inserir a linha "if(lista->ultimo->dados != NULL)
			{free(lista->ultimo->dados);}" antes de "free(lista->ultimo);"
	Proponho as seguintes correções no Smoketest sugerido anterormente:
	#include "../headers/estruturas.h"
	#include <stdlib.h>
	#include <stdio.h>

	int main (void){
		var_lista* lista = aloca_lista();

		var_elemento* elemento = aloca_elemento();

		elemento->dados = (void*) malloc(sizeof(int));

		scanf("%d", (int*) elemento->dados);
		//Input: 3\n
		insere_final(elemento->dados,lista,INSERE_DADO_HEAP);
		/*A área de memória apontada por elemento->dados
		nesse momento foi entregue a função*/

		elemento->dados = (void*) malloc(sizeof(int));

		scanf("%d", (int*) elemento->dados);
		//Input: 6\n
		insere_final(elemento,lista,INSERE_VAR_ELEMENTO);

		deleta_ultimo(lista);
		//Esperado que o 6 seja deletado

		print_lista(lista,INT);

		free_lista(lista);

		return 0;
	}
	Ao executar o programa acima é esperado que ao final não existam
	vazamentos e seja impresso no terminal "1. 3".
	Checklist
		Segunda Tentativa 06/11/2017
		Resultado: Sucesso, sem vazamentos de memória.
	Ao final da tarde começei a implementar uma função para terceirizar
	o processo de alocação de memória para os principais tipos usados
	durante a solução do problema.
	Entretanto achei estéticamente feio e pouco prático, então retirei.
================================================================================
08/11/2017 17:00
	Recebi o pedido para o trabalho ontem
	Modificarei a definição de lista simplemente encadeada implementada
	para uma lista duplamente encadeada:

	typedef struct elemento{
		void* dados;
		struct elemento* anterior;
	    struct elemento* proximo;
	} var_elemento;

	Incluindo modificações nas seguintes funções:
	var_elemento*	aloca_elemento (void)

	void			insere_final (void* info, var_lista* lista, int codigo);

	Ampliando a função 'insere_final' surgiu:
	void			insere (int finalouinicio, void* info, var_lista* lista,
 int codigo);

	Smoketest para lista uplamente encadeada:
	Proponho a repetição do Smoketest do dia 06/11 com as alterações
	feitas no programa:
	Checklist
		Primeira Tentativa 08/11/2017
		Resultado: Sucesso, testando com ambas inserções no ínicio e no final
	Começei a implementar a biblioteca 'character.h'
================================================================================
12/11/2017 15:30
	Começei a tarde criando um repositório
	https://github.com/thaleslim/GameGoT.git
	e começarei a testar as funções que imaginei enquanto
	estava impossibilitado de trabalhar no projeto,
	pretendo depurar as seguintes funções:
	t_node*     node_create(void);

	t_node*     tree_create(void);

	t_node*     aloca_arvore(int total_de_nos);

	void        tree_free(t_node* tree);

	void        tree_print_preorder(t_node* root);

	Resolvi compartimentar cada estrutura de dados em seu próprio
	cabeçalho
	Proponho o seguinte Smoketest:
	#include "../headers/arvore.h"
	int main(void)
	{
		t_node* node = node_create();
		tree_free(node);
		tree_free(tree_create());
		return 0;
	}
	No qual é esperado a criação e liberação de um único nó e
	a criação e liberação de uma árvore binária completa de 4
	níveis, sem vazamentos ou erros.
	Checklist
		Primeira Tentativa 12/11/2017
		Resultado: Sucesso, sem vazamentos de memória.
	Observação: existe a possibilidade,apesar de minima, de existirem erros de construção
	  			da estrutura de árvore.
================================================================================
16/11/2017 14:30
	Objetivos: implementar a estrutura de fila
	usando listas duplamente encadeadas.
	Testar modificações para
	generalizar o comportamento de inserir adicionando
	uma variável, que seria a quantidade de bytes da
	informação que o usuário quer inserir.
	E começar a implementar funções mais específicas de
	modelagem do jogo.

	Proponho o seguinte Smoketest para os 2 primeiros objetivos:
	#include "../headers/fila.h"
	#include <stdio.h>

	int main(void)
	{
		var_fila* fila = aloca_fila();

		int numero = 4;

		print_fila(fila, INT);

		entrar_fila(&numero, sizeof(int), fila);

		numero = 7;

		entrar_fila(&numero, sizeof(int), fila);

		print_fila(fila, INT);

		int* ponteiro_numero = (int*) sair_fila(fila);

		printf("%d", *ponteiro_numero);

		free_fila(fila);

		free(ponteiro_numero);

		return 0;
	}
	Resultado esperado: imprimi LISTA VAZIA,
	 					enfileira 4 e 7,
						imprimi 1. 4
								2. 7
						desenfileira 4
						resta na fila 7
						imprimi 4
						libera fila sem vazamentos.
	Checklist
		Primeira Tentativa 16/11/2017
		Resultado: Falha de Segmentação após imprimir LISTA VAZIA.
================================================================================
17/11/2017 18:00
	Objetivos:  Depurar estrutura de fila;
				Atualizar git repo;
				Voltar a desenvolver funções mais especificas do jogo em si.
	Erro: 'insere_lista' causa vazamento de memória
		Correção: usar chaves para abranger as 2 linhas de código
				do elseif caso contrário "memcpy(elemento, info, size_of_memory);"
				é executado todas as vezes.
	Comportamento não desejado: 'sair_fila' retorna um 'var_elemento'
		Correção: adicionar as seguintes ações"void *resultado=elemento->dados;
				free(elemento);"
	Estética: substituir LISTA VAZIA por VAZIA
			Como estamos usando print_lista para mais de uma estrutura, faz mais
			sentido dessa forma.
	Checklist
		Segunda Tentativa 17/11/2017
		Resultado: Sucesso, sem vazamentos de memória.
================================================================================
18/11/2017 12:15
	Objetivos:	Começar a modelar o gameloop
				Implementar funções de busca e impressão na árvore
	Começei criando o arquivo Sketch.c
	Esse arquivo contém o q eu imagino que seja necessário para
	a montagem do gameloop
================================================================================
22/11/2017 21:56
	Objetivos:	Testar character_create()
				Implementar LoadFromFile(), função mencionada em sketch.c
	Proponho o seguinte SmokeTest:
	#include "../headers/character.h"
	int main (void)
	{
		char _name[] = "Jon Snow", _house[] = "Snow";
		int _agility = 40, _strength = 30 , _intelligence = 20, _health = 10;
		character_free(character_create(_name, _house, _agility, _strength,
		_intelligence, _health));
		return 0;
	}
	Resultado esperado: Alocar uma estrutura Character e liberá-la sem falhas
						ou vazamentos.
	CheckList:
				Primeira Tentativa 22/11/2017 22:00
				Resultado: Sucesso, sem falhas ou vazamentos.
	Resultados do dia:

	Character* character_create(char* _name, char* _house, int _agility,
	int _strength, int _intelligence, int _health);

	void       character_free(Character* character);

	Character* fight(Character* fighter_one, Character* fighter_two,
	int atribute);

	void       print_character(Character* character, void* nerfs_n_buffs);

	Funções implementadas e testadas, entretanto print_character()
	será expandida para facilitar o trabalho de impressão levando
	em consideração dinâmicas do jogo, nesse caso imprimir
	"X) XXXXXX: XX" no atributo "exaurido" pelo usuário na batalha
	anterior.

	Testes realizados usando as seguintes estruturas Character:
	KungLao, Lao, 100, 30, 20, 100
	ChunLee, Lee, 15, 100, 100, 20
